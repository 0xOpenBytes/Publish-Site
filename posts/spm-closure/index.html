<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="0xOpenBytes"/><link rel="canonical" href="https://openbytes.dev/posts/spm-closure"/><meta name="twitter:url" content="https://openbytes.dev/posts/spm-closure"/><meta name="og:url" content="https://openbytes.dev/posts/spm-closure"/><title>Closure SPM üì¶ | 0xOpenBytes</title><meta name="twitter:title" content="Closure SPM üì¶ | 0xOpenBytes"/><meta name="og:title" content="Closure SPM üì¶ | 0xOpenBytes"/><meta name="description" content="Define and chain Closures with Inputs and Outputs"/><meta name="twitter:description" content="Define and chain Closures with Inputs and Outputs"/><meta name="og:description" content="Define and chain Closures with Inputs and Outputs"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to 0xOpenBytes"/><meta name="twitter:image" content="https://openbytes.dev/https://avatars.githubusercontent.com/u/92551192%3Fs=200&v=4"/><meta name="og:image" content="https://openbytes.dev/https://avatars.githubusercontent.com/u/92551192%3Fs=200&v=4"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">0xOpenBytes</a><nav><ul><li><a href="/posts" class="selected">Posts</a></li><li><a href="/about">About</a></li><li><a href="/projects">Projects</a></li><li><a href="/github">Github</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>Closure SPM üì¶</h1><p>üîó <a href="https://github.com/0xLeif/Closure"><em>Check out Closure</em></a></p><br/><pre id=pre-shell data-language="shell" "><code>git clone git@github.com:0xLeif/Closure.git
</code></pre><br/><h2>Defining a Closure</h2><p><em>"A Closure is a block of code that can be executed by reference of a variable or name. Closures in Swift are normally unnamed and passed in as a parameter variable or stored as a variable."</em></p><p>üîó <a href="/posts/swiftlet-05-closures/">source</a></p><br/><br/><h3>Closure.swift</h3><br/><p>When we define a Closure we can assume that it will always have an <code>Input</code> and an <code>Output</code>. Either value could be <code>Void</code> in the case that a value doesn't exist. Knowing this we can expect that our object look something like, <code>Closure&lt;Input, Output&gt;</code>. We will need an actual closure when we initialize our <code>Closure</code> object. This value should look something like this, <code>(Input) -&gt; Output</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">/// A Struct that defines a Closure with a given Input and a given Output</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span>&lt;<span class="hljs-title">Input</span>, <span class="hljs-title">Output</span>&gt; </span>{
  <span class="hljs-comment">/// The Closure passed in during initialization</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> method: (<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>
  
  <span class="hljs-comment">/// Initialize a Closure without any scoped state</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(
    <span class="hljs-number">_</span> closure: @escaping (<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>
  ) {
    method = closure
  }
}
</code></pre><p>Notice that we must specify that the closure is <code>@escaping</code>. This is becuase we will store it in a variable that we can keep for the lifetime of the object. In other words <code>@escaping</code> means that the closure can leave the scope of the function it is passed into.</p><br/><br/><h3>Running the Closure</h3><br/><p>Now that we have defined the basic <code>Closure</code> object we can start running the closure! Currently we would need to reach into the object. You will also notice that we need to pass in <code>()</code> which is the Void type.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> sayHello = <span class="hljs-type">Closure</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello üëã"</span>)
}

sayHello.method(())
</code></pre><p><em>In this example, <code>sayHello</code> is of type <code>Closure&lt;Void, Void&gt;</code>.</em></p><br/><br/><h3>Extending Closure</h3><br/><p>Now we will create a function to run the <code>Closure</code> with the required <code>Input</code> and potentially a completion handler. This will make it easier to call the method instead of having to reach into the object.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> </span>{
  <span class="hljs-comment">/// Run the Closure with Input and a Completion Handler</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(
    input: Input,
    onCompletion onCompletionHandler: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span> = {}
  ) -&gt; <span class="hljs-type">Output</span> {
    <span class="hljs-keyword">defer</span> {
      onCompletionHandler()
    }
    <span class="hljs-keyword">return</span> method(input)
  }
}
</code></pre><br/><br/><h4>Void Input Closures</h4><br/><p>Now that we have a run function, we can add another extension for when the <code>Input</code> is <code>Void</code>. We will add another run function where it doesn't require an <code>Input</code> and defaults the value to <code>()</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> <span class="hljs-title">where</span> <span class="hljs-title">Input</span> == <span class="hljs-title">Void</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(
        onCompletion onCompletionHandler: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span> = {}
    ) -&gt; <span class="hljs-type">Output</span> {
        run(
            input: (),
            onCompletion: onCompletionHandler
        )
    }
}
</code></pre><br/><br/><h4>Chaining Closures</h4><br/><p>To be able to chain closures, we would need to receive some new closure to run. We can expect that this closure will look very similar to the closure we already have, but it could have some new output. The closure should look similar to this, <code>@escaping (Output) -&gt; NewOutput</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> </span>{
  <span class="hljs-comment">/// Chain another Closure with a NewOutput</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">then</span>&lt;NewOutput&gt;<span class="hljs-params">(
    <span class="hljs-number">_</span> closure: @escaping <span class="hljs-params">(Output)</span></span></span> -&gt; <span class="hljs-type">NewOutput</span>
  ) -&gt; <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Input</span>, <span class="hljs-type">NewOutput</span>&gt; {
    <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Input</span>, <span class="hljs-type">NewOutput</span>&gt; { input <span class="hljs-keyword">in</span>
      closure(method(input))
    }
  }
}
</code></pre><p>Looking at this function, note that we pass the <code>Output</code> of <code>method(input)</code> into the new closure. Using <code>then</code>, we are able to make a new <code>Closure</code> where we still pass in the same type of <code>Input</code>, but now the <code>NewOutput</code> could be the same or different than <code>Output</code>.</p><br/><p><strong>Chaining Closures Example</strong></p><br/><p>Psuedo Code</p><p><code>Closure&lt;Void, Void&gt; -&gt; Closure&lt;Void, Int&gt; -&gt; Closure&lt;Void, Void&gt;</code></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> sayHello: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Void</span>&gt; = <span class="hljs-type">Closure</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)
}
.then {
    <span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">0</span> ... <span class="hljs-number">9</span>)
}
.then { randomInt <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"I got this random int: \(randomInt) ü§∑‚Äç‚ôÇÔ∏è"</span>)
}
</code></pre><p><em>In this example, <code>sayHello</code> is still of type <code>Closure&lt;Void, Void&gt;</code>.</em></p><br/><br/><h2>Stateful Closure</h2><br/><p>ü§î <em>What is a stateful closure?</em></p><br/><p>Could we have a Closure that has some state? For example, could we have a closure that returns a value and each time we run it it increments one to the value.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> statefulCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Int</span>&gt; = ...

<span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ... <span class="hljs-number">9</span> {
    <span class="hljs-built_in">print</span>(statefulCount.run())
}

<span class="hljs-comment">/** Output
0
1
2
3
4
5
6
7
8
9
*/</span>
</code></pre><br/><p>To do this we need a new init!</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span>&lt;<span class="hljs-title">Input</span>, <span class="hljs-title">Output</span>&gt; </span>{
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-comment">/// Initialize a Closure with potential scoped state</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(
        <span class="hljs-number">_</span> closure: () -&gt; ((<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>)
    ) {
        method = closure()
    }
}
</code></pre><br/><ul><li>In the example above where we have <code>statefulCount</code>. The <code>Closure</code> was defined with the following code.</li></ul><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> statefulCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Closure</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">return</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">defer</span> {
            <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>
    }
}
</code></pre><br/><br/><hr><br/><br/><p><strong>Extra Examples</strong></p><br/><p><strong>No State</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> noStateCount = <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; { text <span class="hljs-keyword">in</span>
  <span class="hljs-type">String</span>(repeating: text, <span class="hljs-built_in">count</span>: <span class="hljs-number">4</span>)
}
.then { string <span class="hljs-keyword">in</span>
  <span class="hljs-type">Int</span>(string) ?? <span class="hljs-number">0</span>
}


<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
</code></pre><br/><p><strong>State</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> stateCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; {
  <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>
  
  <span class="hljs-keyword">return</span> { text <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">defer</span> {
      <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-type">String</span>(repeating: text, <span class="hljs-built_in">count</span>: <span class="hljs-built_in">count</span>)
  }
}
.then { string <span class="hljs-keyword">in</span>
  <span class="hljs-type">Int</span>(string) ?? <span class="hljs-number">0</span>
}

<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5</span>)
<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">55</span>)
<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">555</span>)
</code></pre><p>‚¨ÜÔ∏è <a href="/posts/spm-closure/">Back to the Top</a></p></div><span>Tagged with: </span><ul class="tag-list"><li class="tag" id="tag-swift"><a href="/tags/spm">spm</a></li><li class="tag" id="tag-swift"><a href="/tags/swift">swift</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>