<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>0xOpenBytes</title><description>Independent developers looking to help others learn and overcome the many obstacles software development has to offer.</description><link>https://openbytes.dev</link><language>en</language><lastBuildDate>Mon, 27 Dec 2021 15:19:19 +0000</lastBuildDate><pubDate>Mon, 27 Dec 2021 15:19:19 +0000</pubDate><ttl>250</ttl><atom:link href="https://openbytes.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://openbytes.dev/posts/kotlin-infix</guid><title>Kotlin infix notation</title><description>Kotlin infix</description><link>https://openbytes.dev/posts/kotlin-infix</link><pubDate>Fri, 24 Dec 2021 20:24:00 +0000</pubDate><content:encoded><![CDATA[<h1>Kotlin infix notation</h1><h3>What does it do</h3><p>The <code>infix</code> keyword can be applied to kotlin functions. This simply allows it to be called without requiring parenthesis for its parameter.</p><p>Here's a small example with a <code>Player</code> that can hold a <code>card</code> at any given time. The player can <code>swapCard</code> if the other card's value is greater than the one they hold. We apply the <code>infix</code> notation to the <code>swapCard</code> function.</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>(card: Card) {

    <span class="hljs-keyword">var</span> card: Card = card
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>

    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swapCard</span><span class="hljs-params">(other: <span class="hljs-type">Card</span>)</span></span> {
        <span class="hljs-keyword">if</span> (other.value &gt; card.value) {
            card = other
        }
    }
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Player Card :: <span class="hljs-subst">${card.value}</span>"</span>
    }
}

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span></span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>)
</code></pre><p>Lets try swapping a players card</p><pre id=pre-kotlin data-language="kotlin" "><code>    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> `test swap`<span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> purplePlayer = Player(Card(<span class="hljs-number">4</span>))

        purplePlayer swapCard Card(<span class="hljs-number">6</span>)

        println(purplePlayer) <span class="hljs-comment">// successful swap </span>
        <span class="hljs-comment">// prints Player Card :: 6</span>

        purplePlayer swapCard Card(<span class="hljs-number">5</span>) <span class="hljs-comment">//unsuccessful swap</span>
        <span class="hljs-comment">// prints Player Card :: 6</span>

        println(purplePlayer)
    }
</code></pre><p>We're able to call the <code>swapCard</code> function without using the parenthesis.</p><h3>Constriants</h3><p>Only a single parameter can be passed into them.</p><pre id=pre-kotlin data-language="kotlin" "><code>	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>(...) {
	...
	<span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swapTwo</span><span class="hljs-params">(other: <span class="hljs-type">Card</span>, cardB: <span class="hljs-type">Card</span>)</span></span> { ... } <span class="hljs-comment">// will NOT compile</span>
	...	
}
</code></pre><h3>Usage in standard library</h3><p>Infix functions are already used within the standard Kotlin library as well. <code>until</code> returns a range from the provided lower and upper bound.</p><pre id=pre-kotlin data-language="kotlin" "><code>    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> `range demonstration`<span class="hljs-params">()</span></span> {
        (<span class="hljs-number">0</span> until <span class="hljs-number">10</span>).forEach {
            print(it)
        }
    }
	<span class="hljs-comment">// prints 0123456789</span>
</code></pre><p>Another common usage is the <code>to</code> infix function when adding elements to a map.</p><pre id=pre-kotlin data-language="kotlin" "><code>    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> `map to demonstration`<span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> dummyMap = mapOf(
            <span class="hljs-string">"One"</span> to <span class="hljs-number">1</span>,
            <span class="hljs-string">"Two"</span> to <span class="hljs-number">2</span>
        )
		dummyMap.forEach { (k, v) -&gt;
            print(<span class="hljs-string">"<span class="hljs-variable">$k</span> <span class="hljs-variable">$v</span> "</span>)
        }
    }
	<span class="hljs-comment">// prints One 1 Two 2</span>
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/spm-closure</guid><title>Closure SPM üì¶</title><description>Define and chain Closures with Inputs and Outputs</description><link>https://openbytes.dev/posts/spm-closure</link><pubDate>Wed, 1 Dec 2021 20:22:00 +0000</pubDate><content:encoded><![CDATA[<h1>Closure SPM üì¶</h1><p>üîó <a href="https://github.com/0xLeif/Closure"><em>Check out Closure</em></a></p><br/><pre id=pre-shell data-language="shell" "><code>git clone git@github.com:0xLeif/Closure.git
</code></pre><br/><h2>Defining a Closure</h2><p><em>"A Closure is a block of code that can be executed by reference of a variable or name. Closures in Swift are normally unnamed and passed in as a parameter variable or stored as a variable."</em></p><p>üîó <a href="https://openbytes.dev/posts/swiftlet-05-closures/">source</a></p><br/><br/><h3>Closure.swift</h3><br/><p>When we define a Closure we can assume that it will always have an <code>Input</code> and an <code>Output</code>. Either value could be <code>Void</code> in the case that a value doesn't exist. Knowing this we can expect that our object look something like, <code>Closure&lt;Input, Output&gt;</code>. We will need an actual closure when we initialize our <code>Closure</code> object. This value should look something like this, <code>(Input) -&gt; Output</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">/// A Struct that defines a Closure with a given Input and a given Output</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span>&lt;<span class="hljs-title">Input</span>, <span class="hljs-title">Output</span>&gt; </span>{
  <span class="hljs-comment">/// The Closure passed in during initialization</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> method: (<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>
  
  <span class="hljs-comment">/// Initialize a Closure without any scoped state</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(
    <span class="hljs-number">_</span> closure: @escaping (<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>
  ) {
    method = closure
  }
}
</code></pre><p>Notice that we must specify that the closure is <code>@escaping</code>. This is becuase we will store it in a variable that we can keep for the lifetime of the object. In other words <code>@escaping</code> means that the closure can leave the scope of the function it is passed into.</p><br/><br/><h3>Running the Closure</h3><br/><p>Now that we have defined the basic <code>Closure</code> object we can start running the closure! Currently we would need to reach into the object. You will also notice that we need to pass in <code>()</code> which is the Void type.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> sayHello = <span class="hljs-type">Closure</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello üëã"</span>)
}

sayHello.method(())
</code></pre><p><em>In this example, <code>sayHello</code> is of type <code>Closure&lt;Void, Void&gt;</code>.</em></p><br/><br/><h3>Extending Closure</h3><br/><p>Now we will create a function to run the <code>Closure</code> with the required <code>Input</code> and potentially a completion handler. This will make it easier to call the method instead of having to reach into the object.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> </span>{
  <span class="hljs-comment">/// Run the Closure with Input and a Completion Handler</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(
    input: Input,
    onCompletion onCompletionHandler: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span> = {}
  ) -&gt; <span class="hljs-type">Output</span> {
    <span class="hljs-keyword">defer</span> {
      onCompletionHandler()
    }
    <span class="hljs-keyword">return</span> method(input)
  }
}
</code></pre><br/><br/><h4>Void Input Closures</h4><br/><p>Now that we have a run function, we can add another extension for when the <code>Input</code> is <code>Void</code>. We will add another run function where it doesn't require an <code>Input</code> and defaults the value to <code>()</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> <span class="hljs-title">where</span> <span class="hljs-title">Input</span> == <span class="hljs-title">Void</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(
        onCompletion onCompletionHandler: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span> = {}
    ) -&gt; <span class="hljs-type">Output</span> {
        run(
            input: (),
            onCompletion: onCompletionHandler
        )
    }
}
</code></pre><br/><br/><h4>Chaining Closures</h4><br/><p>To be able to chain closures, we would need to receive some new closure to run. We can expect that this closure will look very similar to the closure we already have, but it could have some new output. The closure should look similar to this, <code>@escaping (Output) -&gt; NewOutput</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> </span>{
  <span class="hljs-comment">/// Chain another Closure with a NewOutput</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">then</span>&lt;NewOutput&gt;<span class="hljs-params">(
    <span class="hljs-number">_</span> closure: @escaping <span class="hljs-params">(Output)</span></span></span> -&gt; <span class="hljs-type">NewOutput</span>
  ) -&gt; <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Input</span>, <span class="hljs-type">NewOutput</span>&gt; {
    <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Input</span>, <span class="hljs-type">NewOutput</span>&gt; { input <span class="hljs-keyword">in</span>
      closure(method(input))
    }
  }
}
</code></pre><p>Looking at this function, note that we pass the <code>Output</code> of <code>method(input)</code> into the new closure. Using <code>then</code>, we are able to make a new <code>Closure</code> where we still pass in the same type of <code>Input</code>, but now the <code>NewOutput</code> could be the same or different than <code>Output</code>.</p><br/><p><strong>Chaining Closures Example</strong></p><br/><p>Psuedo Code</p><p><code>Closure&lt;Void, Void&gt; -&gt; Closure&lt;Void, Int&gt; -&gt; Closure&lt;Void, Void&gt;</code></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> sayHello: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Void</span>&gt; = <span class="hljs-type">Closure</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)
}
.then {
    <span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">0</span> ... <span class="hljs-number">9</span>)
}
.then { randomInt <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"I got this random int: \(randomInt) ü§∑‚Äç‚ôÇÔ∏è"</span>)
}
</code></pre><p><em>In this example, <code>sayHello</code> is still of type <code>Closure&lt;Void, Void&gt;</code>.</em></p><br/><br/><h2>Stateful Closure</h2><br/><p>ü§î <em>What is a stateful closure?</em></p><br/><p>Could we have a Closure that has some state? For example, could we have a closure that returns a value and each time we run it it increments one to the value.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> statefulCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Int</span>&gt; = ...

<span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ... <span class="hljs-number">9</span> {
    <span class="hljs-built_in">print</span>(statefulCount.run())
}

<span class="hljs-comment">/** Output
0
1
2
3
4
5
6
7
8
9
*/</span>
</code></pre><br/><p>To do this we need a new init!</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span>&lt;<span class="hljs-title">Input</span>, <span class="hljs-title">Output</span>&gt; </span>{
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-comment">/// Initialize a Closure with potential scoped state</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(
        <span class="hljs-number">_</span> closure: () -&gt; ((<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>)
    ) {
        method = closure()
    }
}
</code></pre><br/><ul><li>In the example above where we have <code>statefulCount</code>. The <code>Closure</code> was defined with the following code.</li></ul><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> statefulCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Closure</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">return</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">defer</span> {
            <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>
    }
}
</code></pre><br/><br/><hr><br/><br/><p><strong>Extra Examples</strong></p><br/><p><strong>No State</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> noStateCount = <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; { text <span class="hljs-keyword">in</span>
  <span class="hljs-type">String</span>(repeating: text, <span class="hljs-built_in">count</span>: <span class="hljs-number">4</span>)
}
.then { string <span class="hljs-keyword">in</span>
  <span class="hljs-type">Int</span>(string) ?? <span class="hljs-number">0</span>
}


<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
</code></pre><br/><p><strong>State</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> stateCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; {
  <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>
  
  <span class="hljs-keyword">return</span> { text <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">defer</span> {
      <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-type">String</span>(repeating: text, <span class="hljs-built_in">count</span>: <span class="hljs-built_in">count</span>)
  }
}
.then { string <span class="hljs-keyword">in</span>
  <span class="hljs-type">Int</span>(string) ?? <span class="hljs-number">0</span>
}

<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5</span>)
<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">55</span>)
<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">555</span>)
</code></pre><p>‚¨ÜÔ∏è <a href="https://openbytes.dev/posts/spm-closure/">Back to the Top</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/an-intro-into-screendata-in-2021</guid><title>An Intro into ScreenData in 2021</title><description>Introduction into ScreenData in 2021</description><link>https://openbytes.dev/posts/an-intro-into-screendata-in-2021</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>An Intro into ScreenData in 2021</h1><p><a href="https://github.com/ServerDriven/ScreenData">ScreenData</a> is a data model for displaying UI Screens. A <strong>Screen</strong> is what contains all the views for ScreenData. <strong>Screens</strong> have <strong>Views</strong> which contain all the information they need to be displayed to the screen. <strong>ContainerViews</strong> can have multiple <strong>Views</strong> and specify a axis, horizontal or vertical, which the <strong>Views</strong> are aligned on. <strong>Views</strong> can have destinations which link to another <strong>Screen</strong>.</p><p>Since ScreenData is a data model, any programming language can implement it! Currently there are two implementations of ScreenData, <a href="https://github.com/ServerDriven/ScreenData-kotlin">Kotlin</a> and <a href="https://github.com/ServerDriven/ScreenData-swift">Swift</a>. Official ScreenData repositories have been created for <a href="https://github.com/ServerDriven/ScreenData-typescript">Typescript</a>, <a href="https://github.com/ServerDriven/ScreenData-rust">Rust</a>, and <a href="https://github.com/ServerDriven/ScreenData-dart">Dart</a>. All are open for anyone to implement.</p><p>After you have chosen your preferred ScreenData implementation, you can start deciding how you will get some <strong>Screen</strong> and optionally store it. For instance here are some examples.</p><ul><li>Storing the ScreenData or JSON locally to be able to fetch it instantly</li><li>Fetching the data from a server</li><li>Fetch the data from a server, but then cache a local version of the data until some indeterminate time in the future</li></ul><h2>ScreenDataUI and CustomView</h2><p>All of these decisions are influenced by what ScreenDataUI implementation you choose. Currently there are two implementations of ScreenDataUI, <a href="https://github.com/ServerDriven/ScreenDataUI-ios">iOS (SwiftUI)</a> and <a href="https://github.com/ServerDriven/ScreenDataUI-android">Android (Compose)</a>. These implementations are intended to be a 1:1 implementation of ScreenData for mobile. Not all implementations use everything that ScreenData has to offer. If you find ScreenData doesn‚Äôt have what you need, you can always use a <strong>CustomView</strong>. When using a <strong>CustomView</strong>, the front end will need to have its own implementation of the view. <strong>CustomViews</strong> should use an id so that the front end can tell what to display.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-01-variables</guid><title>SwiftLet #01: Variables</title><description>SwiftLet #01</description><link>https://openbytes.dev/posts/swiftlet-01-variables</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #01: Variables</h1><p>One can think of variables as a named value. The value of the variable could be anything: a number, some words, an image, etc. All variables need to be <strong>set</strong> before we can <strong>get</strong> the actual value.</p><p><code>{Keyword} {Variable Name}(: {Type}) = ({Value})</code></p><p>It is required to specify if the variable is constant or modifiable. If the variable is a constant, we will denote that with the keyword of <code>let</code> otherwise if the variable is modifiable, we will use <code>var</code>. After specifying if the variable is a constant or not, we need to give the variable a name! The name of the variable can be anything, in Swift it could even be an emoji! After the variable‚Äôs name, we have the option to specify the type of the value, but this is optional if you set the value on the same line. This is because of Swift‚Äôs type inference! Lastly we have the option of if we want to <strong>set</strong> the variable‚Äôs value now or later, but we <strong>must set</strong> the variable‚Äôs value before trying to <strong>get</strong> it.</p><p><strong>Example 1</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">// Format: {Keyword} {Variable Name} = {Value}</span>
<span class="hljs-keyword">let</span> variable = <span class="hljs-string">"Hello, World!"</span>
</code></pre><p><strong>Example 2</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">// Format: {Keyword} {Variable Name}: {Type} = {Value}</span>
<span class="hljs-keyword">let</span> variable: <span class="hljs-type">String</span> = <span class="hljs-string">"Hello, World!"</span>
</code></pre><p><strong>Example 3</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">// Format: {Keyword} {Variable Name}: {Type}</span>
<span class="hljs-keyword">let</span> variable: <span class="hljs-type">String</span>

variable = <span class="hljs-string">"ü•á"</span>
</code></pre><p><strong>Basic Types</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> boolean: <span class="hljs-type">Bool</span> = <span class="hljs-type">Bool</span>.random() <span class="hljs-comment">// true or false </span>
<span class="hljs-keyword">let</span> integer: <span class="hljs-type">Int</span> = <span class="hljs-type">Int</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">// 9223372036854775807</span>
<span class="hljs-keyword">let</span> float: <span class="hljs-type">Float</span> = <span class="hljs-type">Float</span>.pi <span class="hljs-comment">// 3.1415925</span>
<span class="hljs-keyword">let</span> double: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>.pi <span class="hljs-comment">// 3.141592653589793</span>
<span class="hljs-keyword">let</span> character: <span class="hljs-type">Character</span> <span class="hljs-string">"S"</span>
<span class="hljs-keyword">let</span> string: <span class="hljs-type">String</span> = <span class="hljs-string">"Hello, World!"</span>
</code></pre><p><strong>Collection Types</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> array: [<span class="hljs-type">Int</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
<span class="hljs-keyword">let</span> dictionary: [<span class="hljs-type">String</span>: <span class="hljs-type">Int</span>] = [<span class="hljs-string">"single"</span>: <span class="hljs-number">1</span>]
<span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span>: <span class="hljs-type">Set</span> = <span class="hljs-type">Set</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])
<span class="hljs-comment">// let set: Set = [0, 1, 1, 2] // You can also just say an Array is a Set!</span>
</code></pre><p><strong>The Any Type</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> boolean: <span class="hljs-type">Any</span> = <span class="hljs-type">Bool</span>.random() <span class="hljs-comment">// true or false </span>
<span class="hljs-keyword">let</span> integer: <span class="hljs-type">Any</span> = <span class="hljs-type">Int</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">// 9223372036854775807</span>
<span class="hljs-keyword">let</span> float: <span class="hljs-type">Any</span> = <span class="hljs-type">Float</span>.pi <span class="hljs-comment">// 3.1415925</span>
<span class="hljs-keyword">let</span> double: <span class="hljs-type">Any</span> = <span class="hljs-type">Double</span>.pi <span class="hljs-comment">// 3.141592653589793</span>
<span class="hljs-keyword">let</span> character: <span class="hljs-type">Any</span> <span class="hljs-string">"S"</span>
<span class="hljs-keyword">let</span> string: <span class="hljs-type">Any</span> = <span class="hljs-string">"Hello, World!"</span> 
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-02-let</guid><title>SwiftLet #02: Let</title><description>SwiftLet #02</description><link>https://openbytes.dev/posts/swiftlet-02-let</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #02: Let</h1><p><em>Let is the keyword to define a variable that can only be set once.</em></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> variable: <span class="hljs-type">String</span>

variable = <span class="hljs-string">"üëã"</span>

<span class="hljs-comment">// variable = "üôÖ" // This will result in a compiler error!</span>
</code></pre><p>If you uncomment the line where <code>variable</code> is being set to üôÖ, you will get a compiler error.</p><p><code>Immutable value 'variable' may only be initialized once</code></p><p><strong>NOTE:</strong> <em>It says initialized</em></p><p><strong>Example 1</strong> Simply set the value. Go type inference!</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> pi = <span class="hljs-type">Float</span>.pi
</code></pre><p><strong>Example 2</strong> What if we tried to modify the value? In this example, we are trying to modify an Array after it has been initialized, in Swift Arrays are <strong>Value Types</strong> <em>(in a later chapter we will dive into the topic of <strong>Value Types</strong> and <strong>Reference Types</strong>)</em>.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> variable: [<span class="hljs-type">String</span>]

variable = [<span class="hljs-string">"üëã"</span>]

variable.append(<span class="hljs-string">"üôÖ"</span>) <span class="hljs-comment">// This will also result in a compiler error!</span>
</code></pre><p>The error you get is because <strong>Value Types</strong> are always reinitialized! Their value changed, so it is a <strong>new</strong> value.</p><p><code>Mutating method 'append' may not be used on immutable value 'variable'</code></p><p><strong>Example 3</strong> We can <strong>get</strong> the variable and use the value, in this example we print the current value to the console.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> variable = <span class="hljs-string">"üëã"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üëã</span>
</code></pre><p><strong>Closing Remarks</strong></p><p>We learned that <code>let</code> can only <strong>set</strong> a variable‚Äôs value once! Also we learned that we can <strong>get</strong> the value of a variable and use it. Finally we learned that Swift has <strong>Value Types</strong> and <strong>Reference Types</strong>; also that you can not modify a variable which happens to be a <strong>Value Type</strong>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-03-var</guid><title>SwiftLet #03: Var</title><description>SwiftLet #03</description><link>https://openbytes.dev/posts/swiftlet-03-var</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #03: Var</h1><p><em>Var is the keyword to define a variable.</em></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> variable: <span class="hljs-type">String</span>

variable = <span class="hljs-string">"üëã"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üëã</span>

variable = <span class="hljs-string">"üò±"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üò±</span>
</code></pre><p><strong>Example 1</strong></p><p>Some types allow for the use of different operators! So far we have only used the assignment operator (<strong>=</strong>). For this example we will try using the addition operator (<strong>+</strong>).</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> variable: <span class="hljs-type">String</span>

variable = <span class="hljs-string">"üëã"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üëã</span>

variable = variable + <span class="hljs-string">"üò±"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üëãüò±</span>
</code></pre><p><strong>Example 2</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> variable: [<span class="hljs-type">String</span>]

variable = [<span class="hljs-string">"üëã"</span>]

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// ["üëã"]</span>

variable.append(<span class="hljs-string">"ü§™"</span>)

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// ["üëã", "ü§™"]</span>
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-04-optionals</guid><title>SwiftLet #04: Optionals</title><description>SwiftLet #04</description><link>https://openbytes.dev/posts/swiftlet-04-optionals</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #04: Optionals</h1><p><em>What if a variable shouldn‚Äôt have a value?</em></p><p>Great question! Luckily Swift has what are known as Optionals. Optionals <strong>optionally</strong> have a value! Let‚Äôs say we have a variable that is the name of our favorite ice cream.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String</span>
</code></pre><p>Well let‚Äôs say we have a friend that hates ice cream, they don‚Äôt even have a least favorite flavor! You may think, wait can‚Äôt we just put nothing as the string?</p><pre id=pre-swift data-language="swift" "><code>favoriteIceCreamFlavor = <span class="hljs-string">""</span>
</code></pre><p>Sure! Although this could cause issues, why isn‚Äôt the <code>favoriteIceCreamFlavor</code> just <strong>n/a</strong>? In Swift <code>nil</code> is the value denoted to mean nothing or does not exist.</p><p>This is when we want to use optionals! Now we can print out the <code>favoriteIceCreamFlavor</code> and it will print out <code>nil</code>.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor) <span class="hljs-comment">// nil</span>
</code></pre><p>Although now, when we set the <code>favoriteIceCreamFlavor</code> to some flavor and print it out we get some different output than if we used just a <code>String</code> and not an <code>String?</code> (optional string).</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

favoriteIceCreamFlavor = <span class="hljs-string">"Coffee"</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor) <span class="hljs-comment">// Optional("Coffee")</span>
</code></pre><p>For some reason we are getting our favorite ice cream flavor, but it is being wrapped with <code>Optional</code>. In Swift Optionals help us deal with variables that may not always have a value. If we wanted to print out <code>favoriteIceCreamFlavor</code> as a <code>String</code> and not a <code>String?</code>, we just need to unwrap the value! Swift has a few different ways to unwrap an Optional, the first we will discuss is the one you should <strong>almost never use</strong>!</p><p><strong>Force Unwrap</strong> When you force unwrap an Optional in Swift it will return the unwrapped value or crash your program! <strong>Be careful!</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

favoriteIceCreamFlavor = <span class="hljs-string">"Coffee"</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor!) <span class="hljs-comment">// Coffee</span>
</code></pre><p>If we didn‚Äôt have a <code>favoriteIceCreamFlavor</code> set our app would crash and give us an error.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor!)
<span class="hljs-comment">// Fatal error: Unexpectedly found nil while unwrapping an Optional value</span>
<span class="hljs-comment">// Terminated due to signal: ILLEGAL INSTRUCTION (4)</span>
</code></pre><p><strong>Default Unwrap</strong> Instead of force unwrapping, there is always the option to provide a default value if the variable is <code>nil</code>!</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

favoriteIceCreamFlavor = <span class="hljs-string">"Coffee"</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor ?? <span class="hljs-string">"N/A"</span>) <span class="hljs-comment">// Coffee</span>
</code></pre><p>If the variable is <code>nil</code> it will just default to the value we provided.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor ?? <span class="hljs-string">"N/A"</span>) <span class="hljs-comment">// N/A</span>
</code></pre><p><strong>Conditionally Unwrap</strong> Swift also can unwrap Optionals using an <code>if</code> or <code>guard</code> statement. Simply initialize a new variable inside the conditional statement.</p><p><strong>if let</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span> = <span class="hljs-type">Bool</span>.random() ? <span class="hljs-string">"Coffee"</span> : <span class="hljs-literal">nil</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> unwrappedFavoriteIceCreamFlavor = favoriteIceCreamFlavor {
    <span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor) <span class="hljs-comment">// Error: Cannot find 'unwrappedFavoriteIceCreamFlavor' in scope   </span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"None!"</span>)
}
</code></pre><p>This example will randomly set the value of <code>favoriteIceCreamFlavor</code> to ‚ÄúCoffee‚Äú or <code>nil</code>. Then it will only print the ice cream flavor if it is not <code>nil</code>. Otherwise it will just print ‚ÄúNone!‚Äù. Notice that <code>unwrappedFavoriteIceCreamFlavor</code> is a new variable and is only usage within the scope of the statement it belongs to.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span> = <span class="hljs-type">Bool</span>.random() ? <span class="hljs-string">"Coffee"</span> : <span class="hljs-literal">nil</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> unwrappedFavoriteIceCreamFlavor = favoriteIceCreamFlavor,
    unwrappedFavoriteIceCreamFlavor == <span class="hljs-string">"Coffee"</span> {
    <span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor)
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> unwrappedFavoriteIceCreamFlavor = favoriteIceCreamFlavor {
    unwrappedFavoriteIceCreamFlavor = <span class="hljs-string">"Coffee"</span>
    <span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"None!"</span>)
}
</code></pre><p>You can even specify that the locally unwrapped variable is mutable! Which doesn‚Äôt change the original <code>favoriteIceCreamFlavor</code> if that variable is a Value Type. If the variable is a Reference Type, it can modify any variable that is a <code>var</code> and you have access to.</p><p><strong>guard let</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span> = <span class="hljs-type">Bool</span>.random() ? <span class="hljs-string">"Coffee"</span> : <span class="hljs-literal">nil</span>

<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> unwrappedFavoriteIceCreamFlavor = favoriteIceCreamFlavor <span class="hljs-keyword">else</span> {
<span class="hljs-comment">//    print(unwrappedFavoriteIceCreamFlavor) // Error: Cannot find 'unwrappedFavoriteIceCreamFlavor' in scope   </span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"None!"</span>)
    <span class="hljs-keyword">return</span>
}

<span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-05-closures</guid><title>SwiftLet #05: Closures</title><description>SwiftLet #04</description><link>https://openbytes.dev/posts/swiftlet-05-closures</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #05: Closures</h1><p><em>Input and Output</em></p><p>A Closure is a block of code that can be executed by reference of a variable or name. Closures in Swift are normally unnamed and passed in as a parameter variable or stored as a variable. Functions are named blocks of code, they can also be passed in as a parameter for a Closure type.</p><p><strong>Closure Type</strong> The most basic Closure type you can have is one that doesn‚Äôt take any parameter variables (input) and doesn‚Äôt return (output) anything. This Closure type is common and is know as the Void to Void closure.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> closure: () -&gt; <span class="hljs-type">Void</span>
</code></pre><p>The type of this closure denotes that it doesn‚Äôt take any parameters, <code>()</code>, and returns <code>Void</code> which every Closure in Swift, which doesn‚Äôt return a specified type, happens to return <code>Void</code>.</p><p>Another example for a Closure type could be one that takes in some <code>Int</code> and returns some <code>String</code>.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> closure: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>

closure = { times <span class="hljs-keyword">in</span>
    <span class="hljs-type">String</span>(repeating: <span class="hljs-string">"üß±"</span>, <span class="hljs-built_in">count</span>: times)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(times: Int)</span></span> -&gt; <span class="hljs-type">String</span> {
    <span class="hljs-type">String</span>(repeating: <span class="hljs-string">"üß±"</span>, <span class="hljs-built_in">count</span>: times)
}

<span class="hljs-built_in">print</span>(closure(<span class="hljs-number">3</span>)) <span class="hljs-comment">// üß±üß±üß±</span>
<span class="hljs-built_in">print</span>(function(times: <span class="hljs-number">3</span>)) <span class="hljs-comment">// üß±üß±üß±</span>
</code></pre><p>Notice that the function has the same Closure type except that it has a named parameter <code>(times: Int) -&gt; String</code>. To show this we can have another function that has a parameter of <code>(Int) -&gt; String</code>.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> closure: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>

closure = { times <span class="hljs-keyword">in</span>
    <span class="hljs-type">String</span>(repeating: <span class="hljs-string">"üß±"</span>, <span class="hljs-built_in">count</span>: times)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(times: Int)</span></span> -&gt; <span class="hljs-type">String</span> {
    <span class="hljs-type">String</span>(repeating: <span class="hljs-string">"üß±"</span>, <span class="hljs-built_in">count</span>: times)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">task</span><span class="hljs-params">(closure: <span class="hljs-params">(Int)</span></span></span> -&gt; <span class="hljs-type">String</span>) {
    <span class="hljs-built_in">print</span>(closure(<span class="hljs-number">5</span>))
}

task(closure: closure) <span class="hljs-comment">// üß±üß±üß±üß±üß±</span>
task(closure: function) <span class="hljs-comment">// üß±üß±üß±üß±üß±</span>
</code></pre>]]></content:encoded></item></channel></rss>