<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>0xOpenBytes</title><description>Self-taught mobile developers looking to help others learn and overcome the many obstacles software development has to offer. Focusing on Kotlin, Swift, and mobile development.</description><link>https://openbytes.dev</link><language>en</language><lastBuildDate>Fri, 20 Jan 2023 00:56:02 +0000</lastBuildDate><pubDate>Fri, 20 Jan 2023 00:56:02 +0000</pubDate><ttl>250</ttl><atom:link href="https://openbytes.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://openbytes.dev/posts/intro-to-swift-charts</guid><title>An Introduction into Swift¬†Charts</title><description>An Introduction into Swift¬†Charts</description><link>https://openbytes.dev/posts/intro-to-swift-charts</link><pubDate>Sat, 3 Dec 2022 19:49:00 +0000</pubDate><content:encoded><![CDATA[<h1>An Introduction into Swift¬†Charts</h1><h2>A barebones no frills introduction to displaying the most basic of charts, a Bar¬†Chart.</h2><br/><p>Swift Charts is a powerful and user-friendly library for creating beautiful and engaging charts in iOS applications. With a simple, and easy implementation method and a wide range of customization options, Swift Charts allows developers to quickly and easily create a variety of chart types, including line, and bar charts. Whether you're a beginner or an experienced developer, Swift Charts is an essential tool for creating engaging data visualizations in your iOS app.</p><br/><img src="https://miro.medium.com/max/1400/1*eBbVaymJUGsTIyRsfv_xbg.webp" alt="Image of a chart displayed on an iPhone which is on a desk" width="100%"/><h2>Great, so how do I implement it?</h2><p>Within the view in which you'd like to display a chart, simply import the Charts library.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">import</span> Charts
</code></pre><p>Then within your view body, you'll simply implement a simple chart of your choice, such as BarMark. We'll implement it in this method within a <code>ForEach</code> in order to allow for customization in the future.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">import</span> SwiftUI
<span class="hljs-keyword">import</span> Charts

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChartView</span>: <span class="hljs-title">View</span> </span>{
  <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
    <span class="hljs-type">VStack</span> {
      <span class="hljs-type">Chart</span> {
        <span class="hljs-type">ForEach</span>(yourDataSet) { data <span class="hljs-keyword">in</span>
          <span class="hljs-type">BarMark</span>(
            x: .value(<span class="hljs-string">"Data Date"</span>, data.date, value: .week)
            y: .value(<span class="hljs-string">"Data Price"</span>, data.price)
          )
        }
      }
    }
  }
}
</code></pre><br/><p>Your data set will need to conform to <a href="https://developer.apple.com/documentation/swift/randomaccesscollection">Random Access Collection</a> and <a href="https://developer.apple.com/documentation/swift/identifiable">Identifiable</a>. For instance, you could create a model for an object you want to represent data for, and then create an array of that model. If your model does not conform to <code>Identifiable</code>, you could get away with simply adding <code>id: \.self</code> within the <code>ForEach</code> parameters.</p><br/><p>As you can see within the XAxis, there is an added parameter called <code>value</code>. If your data model has a variable you're using within your chart that is of type <code>Date</code>, Swift will automatically infer that you're looking to select a <code>DateComponent</code> to set as the value. Which means, you will be able to narrow your data set down to any <code>DateComponent</code>.</p><img src="https://miro.medium.com/max/1400/1*USmHHa9QdYLbX75xmqRK_w.webp" alt="Basic bar chart" width="100%"/><br/><p>As simple as that, we have drawn out a very basic implementation of a Bar Chart. From here, we can work on customizing them to our liking using simple view modifiers provided by the library. In the next article on Swift Charts, I'll detail how I obtained the above visual design.</p><br/><h2>In conclusion</h2><p>Apple did a great job with this framework as it is incredibly intuitive. It provides developers with a very easy way to implement beautiful adaptive graphics to represent various types of data. One thing to keep him ind however is that one chart that is missing from our toolbox is the Pie Chart. After speaking with Apple evangelists during one of the WWDC22 Slack Sessions they do have plans to implement them in the future.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/spm-t</guid><title>Testing code with t SPM üì¶</title><description>üß™ Quickly test expectations</description><link>https://openbytes.dev/posts/spm-t</link><pubDate>Wed, 2 Feb 2022 20:22:00 +0000</pubDate><content:encoded><![CDATA[<h1>Testing code with <code>t</code> SPM üì¶</h1><p>üîó <em><a href="https://github.com/0xOpenBytes/t">Check out t</a></em></p><br/><pre id=pre-shell data-language="shell" "><code>git clone git@github.com:0xOpenBytes/t.git
</code></pre><br/><h2>What is <code>t</code>?</h2><p><code>t</code> is a simple testing framework using closures and errors. You have the ability to create a suite that has multiple steps, expectations, and asserts. Expectations can be used to expect one or multiple assertions. It can be used to test quickly inside a function to make sure something is working as expected. <code>t</code> can also be used in unit test if wanted.</p><br/><br/><h3>Creating a Test Suite</h3><br/><p>Using <code>t.suite(...)</code> you can create a test suite that will return false if any error is thrown. Test suites contains multiple steps, expectations, assertions, and even test suites. All logging will use <code>t.logger</code>, which defaults to <code>print(...)</code>.</p><br/><p><strong>Example Test Suite</strong></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">// Create Test Suite</span>
t.suite {
    <span class="hljs-comment">// Add an expectation that asserting true is true and that 2 is equal to 2</span>
    <span class="hljs-keyword">try</span> t.expect {
        <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-literal">true</span>)
        <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-number">2</span>, isEqualTo: <span class="hljs-number">2</span>)
    }
    
    <span class="hljs-comment">// Add an assertion that asserting false is not true</span>
    <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(notTrue: <span class="hljs-literal">false</span>)
    
    <span class="hljs-comment">// Add an assertion that "Hello" is not equal to "World"</span>
    <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-string">"Hello"</span>, isNotEqualTo: <span class="hljs-string">"World"</span>)
    
    <span class="hljs-comment">// Log a message</span>
    t.log(<span class="hljs-string">"üì£ Test Log Message"</span>)
    
    <span class="hljs-comment">// Log a t.error</span>
    t.log(error: t.error(description: <span class="hljs-string">"Mock Error"</span>))
    
    <span class="hljs-comment">// Add an assertion to check if a value is nil</span>
    <span class="hljs-keyword">let</span> someValue: <span class="hljs-type">String?</span> = <span class="hljs-literal">nil</span>
    <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(isNil: someValue)
    
    <span class="hljs-comment">// Add an assertion to check if a value is not nil</span>
    <span class="hljs-keyword">let</span> someOtherValue: <span class="hljs-type">String?</span> = <span class="hljs-string">"üí†"</span>
    <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(isNotNil: someOtherValue)
}
</code></pre><br/><p><strong>Example Test Suite Output</strong></p><br/><pre id=pre-undefined data-language="undefined" "><code>
üß™ Testing Suite
üîò Expecting something to be true
üì£ Test Log Message
‚ùóÔ∏è Mock Error (
    File: tTests.swift
    Function: testExample()
    Line: 25
)
‚úÖ Suite Passed!
</code></pre><br/><h3>Making Expectations</h3><br/><p>Using <code>t.expect(...)</code> we can make an expectation with one or multiple assertions. We can create variables and log messages too. <strong>The expectation will be true unless some error is thrown.</strong> The error might be thrown by an assertion or can be thrown manually too.</p><br/><p><strong>Example Expectation</strong></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">try</span> t.expect(<span class="hljs-string">"true is true and that 2 is equal to 2"</span>) {
    <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-number">2</span>, isEqualTo: <span class="hljs-number">2</span>)
}
</code></pre><br/><p><strong>Example Expectation Output</strong></p><br/><pre id=pre-undefined data-language="undefined" "><code>
üîò Expecting true is true and that 2 is equal to 2
</code></pre><br/><p><strong>Making an Assertion</strong></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-string">"Hello"</span>, isNotEqualTo: <span class="hljs-string">"World"</span>)
</code></pre><br/><h3>Logging Information</h3><br/><p>Test suite information is automatically logged using <code>t.logger</code>. The logger is a static variable of type <code>(String) -&gt; Void</code> which has a default value of <code>{ print($0) }</code>. Feel free to supply your own logging function. Manual logging should use <code>t.log(String)</code> or <code>t.log(error: Error)</code>.</p><br/><p><strong>Example Manual Logging</strong></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">// Log a message</span>
t.log(<span class="hljs-string">"üì£ Test Log Message"</span>)

<span class="hljs-comment">// Log a t.error</span>
t.log(error: t.error(description: <span class="hljs-string">"Mock Error"</span>))

<span class="hljs-comment">// Log any error</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeError</span>: <span class="hljs-title">Error</span> </span>{ }
t.log(error: <span class="hljs-type">SomeError</span>())
</code></pre><br/><p><strong>Quick Testing</strong></p><br/><pre id=pre-swift data-language="swift" "><code>t.suite {
    <span class="hljs-keyword">try</span> t.expect {
        <span class="hljs-keyword">let</span> expectedValue = ...
        <span class="hljs-keyword">let</span> value = function()
        <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(value, isEqualTo: expectedValue)
    }
}
</code></pre><br/><p><strong>Unit Tests</strong></p><br/><p><strong>XCTAssert Test Suite</strong></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-type">XCTAssert</span>(
    t.suite {
        <span class="hljs-comment">// ...</span>
    }
)
</code></pre><br/><p><strong>XCTAssertNoThrow Expectation</strong></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-type">XCTAssertNoThrow</span>(
    <span class="hljs-keyword">try</span> t.expect(<span class="hljs-string">"true is true and that 2 is equal to 2"</span>) {
        <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-literal">true</span>)
        <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-number">2</span>, isEqualTo: <span class="hljs-number">2</span>)
    }
)
</code></pre><br/><p><strong>XCTAssertNoThrow Assert</strong></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-type">XCTAssertNoThrow</span>(
    <span class="hljs-keyword">try</span> t.<span class="hljs-built_in">assert</span>(<span class="hljs-literal">true</span>)
)
</code></pre><br/><br/><p><a href="https://openbytes.dev/posts/spm-t/">‚¨ÜÔ∏è Back to the Top</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/kotlin-infix</guid><title>Kotlin infix notation</title><description>Kotlin infix</description><link>https://openbytes.dev/posts/kotlin-infix</link><pubDate>Fri, 24 Dec 2021 20:24:00 +0000</pubDate><content:encoded><![CDATA[<h1>Kotlin infix notation</h1><h3>What does it do</h3><br/><p>The <code>infix</code> keyword can be applied to kotlin functions. This simply allows it to be called without requiring parenthesis for its parameter.</p><br/><p>Here's a small example with a <code>Player</code> that can hold a <code>card</code> at any given time. The player can <code>swapCard</code> if the other card's value is greater than the one they hold. We apply the <code>infix</code> notation to the <code>swapCard</code> function.</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>(card: Card) {

    <span class="hljs-keyword">var</span> card: Card = card
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>

    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swapCard</span><span class="hljs-params">(other: <span class="hljs-type">Card</span>)</span></span> {
        <span class="hljs-keyword">if</span> (other.value &gt; card.value) {
            card = other
        }
    }
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Player Card :: <span class="hljs-subst">${card.value}</span>"</span>
    }
}

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span></span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>)
</code></pre><br/><p>Lets try swapping a players card</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `test swap`<span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> purplePlayer = Player(Card(<span class="hljs-number">4</span>))

    purplePlayer swapCard Card(<span class="hljs-number">6</span>)

    println(purplePlayer) <span class="hljs-comment">// successful swap </span>
    <span class="hljs-comment">// prints Player Card :: 6</span>

    purplePlayer swapCard Card(<span class="hljs-number">5</span>) <span class="hljs-comment">//unsuccessful swap</span>
    <span class="hljs-comment">// prints Player Card :: 6</span>

    println(purplePlayer)
}
</code></pre><br/><p>We're able to call the <code>swapCard</code> function without using the parenthesis.</p><br/><h3>Constriants</h3><br/><p>Only a single parameter can be passed into them.</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>(...) {
    ...
    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swapTwo</span><span class="hljs-params">(other: <span class="hljs-type">Card</span>, cardB: <span class="hljs-type">Card</span>)</span></span> { ... } <span class="hljs-comment">// will NOT compile</span>
    ...	
}
</code></pre><br/><h3>Usage in standard library</h3><br/><p>Infix functions are already used within the standard Kotlin library as well. <code>until</code> returns a range from the provided lower and upper bound.</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `range demonstration`<span class="hljs-params">()</span></span> {
    (<span class="hljs-number">0</span> until <span class="hljs-number">10</span>).forEach {
        print(it)
    }
}
<span class="hljs-comment">// prints 0123456789</span>
</code></pre><br/><p>Another common usage is the <code>to</code> infix function when adding elements to a map.</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `map to demonstration`<span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> dummyMap = mapOf(
        <span class="hljs-string">"One"</span> to <span class="hljs-number">1</span>,
        <span class="hljs-string">"Two"</span> to <span class="hljs-number">2</span>
    )
    dummyMap.forEach { (k, v) -&gt;
        print(<span class="hljs-string">"<span class="hljs-variable">$k</span> <span class="hljs-variable">$v</span> "</span>)
    }
}
<span class="hljs-comment">// prints One 1 Two 2</span>
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/reducefold</guid><title>Reduce and Fold</title><description>An introduction to Kotlin's `reduce` and `fold` functions, along with some use cases.</description><link>https://openbytes.dev/posts/reducefold</link><pubDate>Mon, 20 Dec 2021 12:00:00 +0000</pubDate><content:encoded><![CDATA[<br/><h1>Reduce and Fold</h1><br/><p><code>reduce</code> and <code>fold</code> are functions for <code>Iterable</code> types in Kotlin that are used for accumulating values.</p><p>A simple example where we add numbers from 0 till 4. Typically we would write something like</p><br/><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `without`<span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> testList = (<span class="hljs-number">0</span> until <span class="hljs-number">5</span>).toList()
    <span class="hljs-keyword">var</span> acc = <span class="hljs-number">0</span>
    testList.forEach {
        acc += it
    }
    println(<span class="hljs-string">"acc :: <span class="hljs-variable">$acc</span>"</span>) <span class="hljs-comment">// acc :: 10</span>
}
</code></pre><br/><p>We maintain a variable <code>acc</code> that holds the accumulated value.</p><p><code>reduce</code> and <code>fold</code> functions provide both an accumulated value, along with the current value for the loop. In the following example, <code>acc</code> and <code>i</code> are these values respectively. Once the iteration is complete, these functions return the final accumulated value.</p><br/><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `simple demonstration`<span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> testList = (<span class="hljs-number">0</span> until <span class="hljs-number">5</span>).toList()
    <span class="hljs-keyword">val</span> fold = testList.fold(<span class="hljs-number">0</span>) { acc, i -&gt;
        acc + i
    }
    println(<span class="hljs-string">"Fold :: <span class="hljs-variable">$fold</span>"</span>) <span class="hljs-comment">// Fold :: 10</span>
    <span class="hljs-keyword">val</span> reduce = testList.reduce { acc, i -&gt;
        acc + i
    }
    println(<span class="hljs-string">"Reduce :: <span class="hljs-variable">$reduce</span>"</span>) <span class="hljs-comment">// Reduce :: 10</span>
}
</code></pre><br/><p>Similar, but only slightly.</p><br/><h2>Difference</h2><br/><p>Looking at our example, <code>reduce</code> does not explicitly provide a parameter to pass an initial value like <code>fold</code> does. It automatically uses the first item of the iterable type as the initial value.</p><p>But why separate these two, and where would you use one over the other ?</p><p><code>fold</code>'s initial value defines its return type, whereas <code>reduce</code> expects the accumulated value to remain of the same type as the iterable it is being applied to.</p><p>Let's say we wish to iterate over our <code>testList</code> containing the numbers 0 till 4, and simply return a string joining all these numbers. Using <code>fold</code> we could do something like</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `types difference`<span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> testList = (<span class="hljs-number">0</span> until <span class="hljs-number">5</span>).toList()

    <span class="hljs-keyword">val</span> fold = testList.fold(<span class="hljs-string">""</span>) { acc, i -&gt;
        acc.plus(i)
    }

    println(fold)
}
</code></pre><p>where we provide an empty initial string as the first "accumulated" value, and our lamda appends the next number to the string.</p><p><em>Changing the return type would not be possible in <code>reduce</code></em></p><br/><h2>Use case</h2><h3>reduce</h3><br/><p>A user can add multiple items to their basket when shopping, and we wish to display a running total of the price of these items.</p><p>An item is defined as ::</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span></span>(
    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">val</span> name: String,
    <span class="hljs-keyword">val</span> price: <span class="hljs-built_in">Int</span>
)
</code></pre><br/><p>And to generate the price of items for a given list ::</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `reduce use case`<span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> items = listOf(
        Item(
            id = <span class="hljs-number">0</span>,
            name = <span class="hljs-string">"Orange"</span>,
            price = <span class="hljs-number">4</span>
        ),
        Item(
            id = <span class="hljs-number">1</span>,
            name = <span class="hljs-string">"Milk"</span>,
            price = <span class="hljs-number">5</span>
        ),
        Item(
            id = <span class="hljs-number">2</span>,
            name = <span class="hljs-string">"Expensive Potato"</span>,
            price = <span class="hljs-number">15</span>
        )
    )

    <span class="hljs-keyword">val</span> totalPrice = items
        .map { it.price }
        .reduce { acc, i -&gt; acc + i }

    println(<span class="hljs-string">"Total Price :: <span class="hljs-variable">$totalPrice</span>"</span>) <span class="hljs-comment">// prints Total Price :: 24</span>
}
</code></pre><br/><h3>fold</h3><br/><p>Before we send data to our API, we perform client side validation to rid of any basic missing information. The object is complex, so we've created separate validators, each with their own concern.</p><p>Our complex <code>user</code> model</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserModel</span></span>(
    <span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">val</span> name: String,
    <span class="hljs-keyword">val</span> email: String,
    <span class="hljs-keyword">val</span> zipCode: <span class="hljs-built_in">Int</span>
)
</code></pre><br/><p>Our validators for a <code>user</code></p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Validator</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isValid</span><span class="hljs-params">(user: <span class="hljs-type">UserModel</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailValidator</span> : <span class="hljs-type">Validator {</span></span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isValid</span><span class="hljs-params">(user: <span class="hljs-type">UserModel</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">return</span> user.email.contains(<span class="hljs-string">"@"</span>)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZipCodeValidator</span> : <span class="hljs-type">Validator {</span></span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isValid</span><span class="hljs-params">(user: <span class="hljs-type">UserModel</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">return</span> user.zipCode &gt;= <span class="hljs-number">10_000</span>
    }
}
</code></pre><br/><p>And now lets run our validators on an invalid user</p><pre id=pre-kotlin data-language="kotlin" "><code><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `fold use case`<span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> validators = listOf(
        EmailValidator(),
        ZipCodeValidator()
    )
    <span class="hljs-keyword">val</span> userInvalid = UserModel(
        id = <span class="hljs-number">0</span>,
        name = <span class="hljs-string">"Kahani"</span>,
        email = <span class="hljs-string">"kahani#me.com"</span>,
        zipCode = <span class="hljs-number">23_13</span>
    )

    <span class="hljs-keyword">val</span> isUserValid = validators.fold(<span class="hljs-literal">true</span>) { acc, validator -&gt;
        acc &amp;&amp; validator.isValid(userInvalid)
    }
    println(<span class="hljs-string">"UserValid :: <span class="hljs-variable">$isUserValid</span>"</span>) <span class="hljs-comment">// prints UserValid :: false</span>
}
</code></pre><p>The fold iterates through each iterator and flips to false if any validation check fails.</p><br/><h2>Extra bytes</h2><br/><ul><li><strong>What if our Iterable is empty ?</strong></li></ul><br/><p>In this case <code>reduce</code> will throw an exception as it does not know what to return, where as <code>fold</code> will simply return the initial value provided. The <code>reduceOrNull</code> function will return <code>null</code> if you run into a situation where it is unsure if the iterable will be empty or not.</p><br/><br/><ul><li><strong>What if we want the current index throughout the iteration ?</strong></li></ul><br/><p><code>reduceIndexed</code> and <code>foldIndexed</code> provide a third variable, the index, to the lamda.</p><br/><br/><ul><li><strong><code>runningReduce</code> and <code>runningFold</code></strong></li></ul><br/><p>These functions work similar to <code>reduce</code> and <code>fold</code>, however instead of returning the accumulated value, it returns a list of values accumulated over each loop. When I find a better use case for this, I'll expand on it !</p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/spm-closure</guid><title>Closure SPM üì¶</title><description>Define and chain Closures with Inputs and Outputs</description><link>https://openbytes.dev/posts/spm-closure</link><pubDate>Wed, 1 Dec 2021 20:22:00 +0000</pubDate><content:encoded><![CDATA[<h1>Closure SPM üì¶</h1><p>üîó <a href="https://github.com/0xLeif/Closure"><em>Check out Closure</em></a></p><br/><pre id=pre-shell data-language="shell" "><code>git clone git@github.com:0xLeif/Closure.git
</code></pre><br/><h2>Defining a Closure</h2><p><em>"A Closure is a block of code that can be executed by reference of a variable or name. Closures in Swift are normally unnamed and passed in as a parameter variable or stored as a variable."</em></p><p>üîó <a href="https://openbytes.dev/posts/swiftlet-05-closures/">source</a></p><br/><br/><h3>Closure.swift</h3><br/><p>When we define a Closure we can assume that it will always have an <code>Input</code> and an <code>Output</code>. Either value could be <code>Void</code> in the case that a value doesn't exist. Knowing this we can expect that our object look something like, <code>Closure&lt;Input, Output&gt;</code>. We will need an actual closure when we initialize our <code>Closure</code> object. This value should look something like this, <code>(Input) -&gt; Output</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">/// A Struct that defines a Closure with a given Input and a given Output</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span>&lt;<span class="hljs-title">Input</span>, <span class="hljs-title">Output</span>&gt; </span>{
  <span class="hljs-comment">/// The Closure passed in during initialization</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> method: (<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>
  
  <span class="hljs-comment">/// Initialize a Closure without any scoped state</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(
    <span class="hljs-number">_</span> closure: @escaping (<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>
  ) {
    method = closure
  }
}
</code></pre><p>Notice that we must specify that the closure is <code>@escaping</code>. This is becuase we will store it in a variable that we can keep for the lifetime of the object. In other words <code>@escaping</code> means that the closure can leave the scope of the function it is passed into.</p><br/><br/><h3>Running the Closure</h3><br/><p>Now that we have defined the basic <code>Closure</code> object we can start running the closure! Currently we would need to reach into the object. You will also notice that we need to pass in <code>()</code> which is the Void type.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> sayHello = <span class="hljs-type">Closure</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello üëã"</span>)
}

sayHello.method(())
</code></pre><p><em>In this example, <code>sayHello</code> is of type <code>Closure&lt;Void, Void&gt;</code>.</em></p><br/><br/><h3>Extending Closure</h3><br/><p>Now we will create a function to run the <code>Closure</code> with the required <code>Input</code> and potentially a completion handler. This will make it easier to call the method instead of having to reach into the object.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> </span>{
  <span class="hljs-comment">/// Run the Closure with Input and a Completion Handler</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(
    input: Input,
    onCompletion onCompletionHandler: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span> = {}
  ) -&gt; <span class="hljs-type">Output</span> {
    <span class="hljs-keyword">defer</span> {
      onCompletionHandler()
    }
    <span class="hljs-keyword">return</span> method(input)
  }
}
</code></pre><br/><br/><h4>Void Input Closures</h4><br/><p>Now that we have a run function, we can add another extension for when the <code>Input</code> is <code>Void</code>. We will add another run function where it doesn't require an <code>Input</code> and defaults the value to <code>()</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> <span class="hljs-title">where</span> <span class="hljs-title">Input</span> == <span class="hljs-title">Void</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(
        onCompletion onCompletionHandler: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span> = {}
    ) -&gt; <span class="hljs-type">Output</span> {
        run(
            input: (),
            onCompletion: onCompletionHandler
        )
    }
}
</code></pre><br/><br/><h4>Chaining Closures</h4><br/><p>To be able to chain closures, we would need to receive some new closure to run. We can expect that this closure will look very similar to the closure we already have, but it could have some new output. The closure should look similar to this, <code>@escaping (Output) -&gt; NewOutput</code>.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Closure</span> </span>{
  <span class="hljs-comment">/// Chain another Closure with a NewOutput</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">then</span>&lt;NewOutput&gt;<span class="hljs-params">(
    <span class="hljs-number">_</span> closure: @escaping <span class="hljs-params">(Output)</span></span></span> -&gt; <span class="hljs-type">NewOutput</span>
  ) -&gt; <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Input</span>, <span class="hljs-type">NewOutput</span>&gt; {
    <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Input</span>, <span class="hljs-type">NewOutput</span>&gt; { input <span class="hljs-keyword">in</span>
      closure(method(input))
    }
  }
}
</code></pre><p>Looking at this function, note that we pass the <code>Output</code> of <code>method(input)</code> into the new closure. Using <code>then</code>, we are able to make a new <code>Closure</code> where we still pass in the same type of <code>Input</code>, but now the <code>NewOutput</code> could be the same or different than <code>Output</code>.</p><br/><p><strong>Chaining Closures Example</strong></p><br/><p>Psuedo Code</p><p><code>Closure&lt;Void, Void&gt; -&gt; Closure&lt;Void, Int&gt; -&gt; Closure&lt;Void, Void&gt;</code></p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> sayHello: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Void</span>&gt; = <span class="hljs-type">Closure</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)
}
.then {
    <span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">0</span> ... <span class="hljs-number">9</span>)
}
.then { randomInt <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"I got this random int: \(randomInt) ü§∑‚Äç‚ôÇÔ∏è"</span>)
}
</code></pre><p><em>In this example, <code>sayHello</code> is still of type <code>Closure&lt;Void, Void&gt;</code>.</em></p><br/><br/><h2>Stateful Closure</h2><br/><p>ü§î <em>What is a stateful closure?</em></p><br/><p>Could we have a Closure that has some state? For example, could we have a closure that returns a value and each time we run it it increments one to the value.</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> statefulCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Int</span>&gt; = ...

<span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ... <span class="hljs-number">9</span> {
    <span class="hljs-built_in">print</span>(statefulCount.run())
}

<span class="hljs-comment">/** Output
0
1
2
3
4
5
6
7
8
9
*/</span>
</code></pre><br/><p>To do this we need a new init!</p><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span>&lt;<span class="hljs-title">Input</span>, <span class="hljs-title">Output</span>&gt; </span>{
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-comment">/// Initialize a Closure with potential scoped state</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(
        <span class="hljs-number">_</span> closure: () -&gt; ((<span class="hljs-type">Input</span>) -&gt; <span class="hljs-type">Output</span>)
    ) {
        method = closure()
    }
}
</code></pre><br/><ul><li>In the example above where we have <code>statefulCount</code>. The <code>Closure</code> was defined with the following code.</li></ul><br/><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> statefulCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Closure</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">return</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">defer</span> {
            <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>
    }
}
</code></pre><br/><br/><hr><br/><br/><p><strong>Extra Examples</strong></p><br/><p><strong>No State</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> noStateCount = <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; { text <span class="hljs-keyword">in</span>
  <span class="hljs-type">String</span>(repeating: text, <span class="hljs-built_in">count</span>: <span class="hljs-number">4</span>)
}
.then { string <span class="hljs-keyword">in</span>
  <span class="hljs-type">Int</span>(string) ?? <span class="hljs-number">0</span>
}


<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
<span class="hljs-type">XCTAssertEqual</span>(noStateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5555</span>)
</code></pre><br/><p><strong>State</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> stateCount: <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Closure</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; {
  <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>
  
  <span class="hljs-keyword">return</span> { text <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">defer</span> {
      <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-type">String</span>(repeating: text, <span class="hljs-built_in">count</span>: <span class="hljs-built_in">count</span>)
  }
}
.then { string <span class="hljs-keyword">in</span>
  <span class="hljs-type">Int</span>(string) ?? <span class="hljs-number">0</span>
}

<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">5</span>)
<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">55</span>)
<span class="hljs-type">XCTAssertEqual</span>(stateCount.method(<span class="hljs-string">"5"</span>), <span class="hljs-number">555</span>)
</code></pre><p>‚¨ÜÔ∏è <a href="https://openbytes.dev/posts/spm-closure/">Back to the Top</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/an-intro-into-screendata-in-2021</guid><title>An Intro into ScreenData in 2021</title><description>Introduction into ScreenData in 2021</description><link>https://openbytes.dev/posts/an-intro-into-screendata-in-2021</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>An Intro into ScreenData in 2021</h1><br/><p><a href="https://github.com/ServerDriven/ScreenData">ScreenData</a> is a data model for displaying UI Screens. A <strong>Screen</strong> is what contains all the views for ScreenData. <strong>Screens</strong> have <strong>Views</strong> which contain all the information they need to be displayed to the screen. <strong>ContainerViews</strong> can have multiple <strong>Views</strong> and specify a axis, horizontal or vertical, which the <strong>Views</strong> are aligned on. <strong>Views</strong> can have destinations which link to another <strong>Screen</strong>.</p><br/><p>Since ScreenData is a data model, any programming language can implement it! Currently there are two implementations of ScreenData, <a href="https://github.com/ServerDriven/ScreenData-kotlin">Kotlin</a> and <a href="https://github.com/ServerDriven/ScreenData-swift">Swift</a>. Official ScreenData repositories have been created for <a href="https://github.com/ServerDriven/ScreenData-typescript">Typescript</a>, <a href="https://github.com/ServerDriven/ScreenData-rust">Rust</a>, and <a href="https://github.com/ServerDriven/ScreenData-dart">Dart</a>. All are open for anyone to implement.</p><br/><p>After you have chosen your preferred ScreenData implementation, you can start deciding how you will get some <strong>Screen</strong> and optionally store it. For instance here are some examples.</p><br/><ul><li>Storing the ScreenData or JSON locally to be able to fetch it instantly</li><li>Fetching the data from a server</li><li>Fetch the data from a server, but then cache a local version of the data until some indeterminate time in the future</li></ul><br/><h2>ScreenDataUI and CustomView</h2><br/><p>All of these decisions are influenced by what ScreenDataUI implementation you choose. Currently there are two implementations of ScreenDataUI, <a href="https://github.com/ServerDriven/ScreenDataUI-ios">iOS (SwiftUI)</a> and <a href="https://github.com/ServerDriven/ScreenDataUI-android">Android (Compose)</a>. These implementations are intended to be a 1:1 implementation of ScreenData for mobile. Not all implementations use everything that ScreenData has to offer. If you find ScreenData doesn‚Äôt have what you need, you can always use a <strong>CustomView</strong>. When using a <strong>CustomView</strong>, the front end will need to have its own implementation of the view. <strong>CustomViews</strong> should use an id so that the front end can tell what to display.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-01-variables</guid><title>SwiftLet #01: Variables</title><description>SwiftLet #01</description><link>https://openbytes.dev/posts/swiftlet-01-variables</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #01: Variables</h1><p>One can think of variables as a named value. The value of the variable could be anything: a number, some words, an image, etc. All variables need to be <strong>set</strong> before we can <strong>get</strong> the actual value.</p><p><code>{Keyword} {Variable Name}(: {Type}) = ({Value})</code></p><p>It is required to specify if the variable is constant or modifiable. If the variable is a constant, we will denote that with the keyword of <code>let</code> otherwise if the variable is modifiable, we will use <code>var</code>. After specifying if the variable is a constant or not, we need to give the variable a name! The name of the variable can be anything, in Swift it could even be an emoji! After the variable‚Äôs name, we have the option to specify the type of the value, but this is optional if you set the value on the same line. This is because of Swift‚Äôs type inference! Lastly we have the option of if we want to <strong>set</strong> the variable‚Äôs value now or later, but we <strong>must set</strong> the variable‚Äôs value before trying to <strong>get</strong> it.</p><p><strong>Example 1</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">// Format: {Keyword} {Variable Name} = {Value}</span>
<span class="hljs-keyword">let</span> variable = <span class="hljs-string">"Hello, World!"</span>
</code></pre><p><strong>Example 2</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">// Format: {Keyword} {Variable Name}: {Type} = {Value}</span>
<span class="hljs-keyword">let</span> variable: <span class="hljs-type">String</span> = <span class="hljs-string">"Hello, World!"</span>
</code></pre><p><strong>Example 3</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-comment">// Format: {Keyword} {Variable Name}: {Type}</span>
<span class="hljs-keyword">let</span> variable: <span class="hljs-type">String</span>

variable = <span class="hljs-string">"ü•á"</span>
</code></pre><p><strong>Basic Types</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> boolean: <span class="hljs-type">Bool</span> = <span class="hljs-type">Bool</span>.random() <span class="hljs-comment">// true or false </span>
<span class="hljs-keyword">let</span> integer: <span class="hljs-type">Int</span> = <span class="hljs-type">Int</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">// 9223372036854775807</span>
<span class="hljs-keyword">let</span> float: <span class="hljs-type">Float</span> = <span class="hljs-type">Float</span>.pi <span class="hljs-comment">// 3.1415925</span>
<span class="hljs-keyword">let</span> double: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>.pi <span class="hljs-comment">// 3.141592653589793</span>
<span class="hljs-keyword">let</span> character: <span class="hljs-type">Character</span> <span class="hljs-string">"S"</span>
<span class="hljs-keyword">let</span> string: <span class="hljs-type">String</span> = <span class="hljs-string">"Hello, World!"</span>
</code></pre><p><strong>Collection Types</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> array: [<span class="hljs-type">Int</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
<span class="hljs-keyword">let</span> dictionary: [<span class="hljs-type">String</span>: <span class="hljs-type">Int</span>] = [<span class="hljs-string">"single"</span>: <span class="hljs-number">1</span>]
<span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span>: <span class="hljs-type">Set</span> = <span class="hljs-type">Set</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])
<span class="hljs-comment">// let set: Set = [0, 1, 1, 2] // You can also just say an Array is a Set!</span>
</code></pre><p><strong>The Any Type</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> boolean: <span class="hljs-type">Any</span> = <span class="hljs-type">Bool</span>.random() <span class="hljs-comment">// true or false </span>
<span class="hljs-keyword">let</span> integer: <span class="hljs-type">Any</span> = <span class="hljs-type">Int</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">// 9223372036854775807</span>
<span class="hljs-keyword">let</span> float: <span class="hljs-type">Any</span> = <span class="hljs-type">Float</span>.pi <span class="hljs-comment">// 3.1415925</span>
<span class="hljs-keyword">let</span> double: <span class="hljs-type">Any</span> = <span class="hljs-type">Double</span>.pi <span class="hljs-comment">// 3.141592653589793</span>
<span class="hljs-keyword">let</span> character: <span class="hljs-type">Any</span> <span class="hljs-string">"S"</span>
<span class="hljs-keyword">let</span> string: <span class="hljs-type">Any</span> = <span class="hljs-string">"Hello, World!"</span> 
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-02-let</guid><title>SwiftLet #02: Let</title><description>SwiftLet #02</description><link>https://openbytes.dev/posts/swiftlet-02-let</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #02: Let</h1><p><em>Let is the keyword to define a variable that can only be set once.</em></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> variable: <span class="hljs-type">String</span>

variable = <span class="hljs-string">"üëã"</span>

<span class="hljs-comment">// variable = "üôÖ" // This will result in a compiler error!</span>
</code></pre><p>If you uncomment the line where <code>variable</code> is being set to üôÖ, you will get a compiler error.</p><p><code>Immutable value 'variable' may only be initialized once</code></p><p><strong>NOTE:</strong> <em>It says initialized</em></p><p><strong>Example 1</strong> Simply set the value. Go type inference!</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> pi = <span class="hljs-type">Float</span>.pi
</code></pre><p><strong>Example 2</strong> What if we tried to modify the value? In this example, we are trying to modify an Array after it has been initialized, in Swift Arrays are <strong>Value Types</strong> <em>(in a later chapter we will dive into the topic of <strong>Value Types</strong> and <strong>Reference Types</strong>)</em>.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> variable: [<span class="hljs-type">String</span>]

variable = [<span class="hljs-string">"üëã"</span>]

variable.append(<span class="hljs-string">"üôÖ"</span>) <span class="hljs-comment">// This will also result in a compiler error!</span>
</code></pre><p>The error you get is because <strong>Value Types</strong> are always reinitialized! Their value changed, so it is a <strong>new</strong> value.</p><p><code>Mutating method 'append' may not be used on immutable value 'variable'</code></p><p><strong>Example 3</strong> We can <strong>get</strong> the variable and use the value, in this example we print the current value to the console.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> variable = <span class="hljs-string">"üëã"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üëã</span>
</code></pre><p><strong>Closing Remarks</strong></p><p>We learned that <code>let</code> can only <strong>set</strong> a variable‚Äôs value once! Also we learned that we can <strong>get</strong> the value of a variable and use it. Finally we learned that Swift has <strong>Value Types</strong> and <strong>Reference Types</strong>; also that you can not modify a variable which happens to be a <strong>Value Type</strong>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-03-var</guid><title>SwiftLet #03: Var</title><description>SwiftLet #03</description><link>https://openbytes.dev/posts/swiftlet-03-var</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #03: Var</h1><p><em>Var is the keyword to define a variable.</em></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> variable: <span class="hljs-type">String</span>

variable = <span class="hljs-string">"üëã"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üëã</span>

variable = <span class="hljs-string">"üò±"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üò±</span>
</code></pre><p><strong>Example 1</strong></p><p>Some types allow for the use of different operators! So far we have only used the assignment operator (<strong>=</strong>). For this example we will try using the addition operator (<strong>+</strong>).</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> variable: <span class="hljs-type">String</span>

variable = <span class="hljs-string">"üëã"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üëã</span>

variable = variable + <span class="hljs-string">"üò±"</span>

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// üëãüò±</span>
</code></pre><p><strong>Example 2</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> variable: [<span class="hljs-type">String</span>]

variable = [<span class="hljs-string">"üëã"</span>]

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// ["üëã"]</span>

variable.append(<span class="hljs-string">"ü§™"</span>)

<span class="hljs-built_in">print</span>(variable) <span class="hljs-comment">// ["üëã", "ü§™"]</span>
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-04-optionals</guid><title>SwiftLet #04: Optionals</title><description>SwiftLet #04</description><link>https://openbytes.dev/posts/swiftlet-04-optionals</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #04: Optionals</h1><p><em>What if a variable shouldn‚Äôt have a value?</em></p><p>Great question! Luckily Swift has what are known as Optionals. Optionals <strong>optionally</strong> have a value! Let‚Äôs say we have a variable that is the name of our favorite ice cream.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String</span>
</code></pre><p>Well let‚Äôs say we have a friend that hates ice cream, they don‚Äôt even have a least favorite flavor! You may think, wait can‚Äôt we just put nothing as the string?</p><pre id=pre-swift data-language="swift" "><code>favoriteIceCreamFlavor = <span class="hljs-string">""</span>
</code></pre><p>Sure! Although this could cause issues, why isn‚Äôt the <code>favoriteIceCreamFlavor</code> just <strong>n/a</strong>? In Swift <code>nil</code> is the value denoted to mean nothing or does not exist.</p><p>This is when we want to use optionals! Now we can print out the <code>favoriteIceCreamFlavor</code> and it will print out <code>nil</code>.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor) <span class="hljs-comment">// nil</span>
</code></pre><p>Although now, when we set the <code>favoriteIceCreamFlavor</code> to some flavor and print it out we get some different output than if we used just a <code>String</code> and not an <code>String?</code> (optional string).</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

favoriteIceCreamFlavor = <span class="hljs-string">"Coffee"</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor) <span class="hljs-comment">// Optional("Coffee")</span>
</code></pre><p>For some reason we are getting our favorite ice cream flavor, but it is being wrapped with <code>Optional</code>. In Swift Optionals help us deal with variables that may not always have a value. If we wanted to print out <code>favoriteIceCreamFlavor</code> as a <code>String</code> and not a <code>String?</code>, we just need to unwrap the value! Swift has a few different ways to unwrap an Optional, the first we will discuss is the one you should <strong>almost never use</strong>!</p><p><strong>Force Unwrap</strong> When you force unwrap an Optional in Swift it will return the unwrapped value or crash your program! <strong>Be careful!</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

favoriteIceCreamFlavor = <span class="hljs-string">"Coffee"</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor!) <span class="hljs-comment">// Coffee</span>
</code></pre><p>If we didn‚Äôt have a <code>favoriteIceCreamFlavor</code> set our app would crash and give us an error.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor!)
<span class="hljs-comment">// Fatal error: Unexpectedly found nil while unwrapping an Optional value</span>
<span class="hljs-comment">// Terminated due to signal: ILLEGAL INSTRUCTION (4)</span>
</code></pre><p><strong>Default Unwrap</strong> Instead of force unwrapping, there is always the option to provide a default value if the variable is <code>nil</code>!</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

favoriteIceCreamFlavor = <span class="hljs-string">"Coffee"</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor ?? <span class="hljs-string">"N/A"</span>) <span class="hljs-comment">// Coffee</span>
</code></pre><p>If the variable is <code>nil</code> it will just default to the value we provided.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span>

<span class="hljs-built_in">print</span>(favoriteIceCreamFlavor ?? <span class="hljs-string">"N/A"</span>) <span class="hljs-comment">// N/A</span>
</code></pre><p><strong>Conditionally Unwrap</strong> Swift also can unwrap Optionals using an <code>if</code> or <code>guard</code> statement. Simply initialize a new variable inside the conditional statement.</p><p><strong>if let</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span> = <span class="hljs-type">Bool</span>.random() ? <span class="hljs-string">"Coffee"</span> : <span class="hljs-literal">nil</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> unwrappedFavoriteIceCreamFlavor = favoriteIceCreamFlavor {
    <span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor) <span class="hljs-comment">// Error: Cannot find 'unwrappedFavoriteIceCreamFlavor' in scope   </span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"None!"</span>)
}
</code></pre><p>This example will randomly set the value of <code>favoriteIceCreamFlavor</code> to ‚ÄúCoffee‚Äú or <code>nil</code>. Then it will only print the ice cream flavor if it is not <code>nil</code>. Otherwise it will just print ‚ÄúNone!‚Äù. Notice that <code>unwrappedFavoriteIceCreamFlavor</code> is a new variable and is only usage within the scope of the statement it belongs to.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span> = <span class="hljs-type">Bool</span>.random() ? <span class="hljs-string">"Coffee"</span> : <span class="hljs-literal">nil</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> unwrappedFavoriteIceCreamFlavor = favoriteIceCreamFlavor,
    unwrappedFavoriteIceCreamFlavor == <span class="hljs-string">"Coffee"</span> {
    <span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor)
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> unwrappedFavoriteIceCreamFlavor = favoriteIceCreamFlavor {
    unwrappedFavoriteIceCreamFlavor = <span class="hljs-string">"Coffee"</span>
    <span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"None!"</span>)
}
</code></pre><p>You can even specify that the locally unwrapped variable is mutable! Which doesn‚Äôt change the original <code>favoriteIceCreamFlavor</code> if that variable is a Value Type. If the variable is a Reference Type, it can modify any variable that is a <code>var</code> and you have access to.</p><p><strong>guard let</strong></p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">var</span> favoriteIceCreamFlavor: <span class="hljs-type">String?</span> = <span class="hljs-type">Bool</span>.random() ? <span class="hljs-string">"Coffee"</span> : <span class="hljs-literal">nil</span>

<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> unwrappedFavoriteIceCreamFlavor = favoriteIceCreamFlavor <span class="hljs-keyword">else</span> {
<span class="hljs-comment">//    print(unwrappedFavoriteIceCreamFlavor) // Error: Cannot find 'unwrappedFavoriteIceCreamFlavor' in scope   </span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"None!"</span>)
    <span class="hljs-keyword">return</span>
}

<span class="hljs-built_in">print</span>(unwrappedFavoriteIceCreamFlavor)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://openbytes.dev/posts/swiftlet-05-closures</guid><title>SwiftLet #05: Closures</title><description>SwiftLet #04</description><link>https://openbytes.dev/posts/swiftlet-05-closures</link><pubDate>Tue, 30 Nov 2021 17:26:00 +0000</pubDate><content:encoded><![CDATA[<h1>SwiftLet #05: Closures</h1><p><em>Input and Output</em></p><p>A Closure is a block of code that can be executed by reference of a variable or name. Closures in Swift are normally unnamed and passed in as a parameter variable or stored as a variable. Functions are named blocks of code, they can also be passed in as a parameter for a Closure type.</p><p><strong>Closure Type</strong> The most basic Closure type you can have is one that doesn‚Äôt take any parameter variables (input) and doesn‚Äôt return (output) anything. This Closure type is common and is know as the Void to Void closure.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> closure: () -&gt; <span class="hljs-type">Void</span>
</code></pre><p>The type of this closure denotes that it doesn‚Äôt take any parameters, <code>()</code>, and returns <code>Void</code> which every Closure in Swift, which doesn‚Äôt return a specified type, happens to return <code>Void</code>.</p><p>Another example for a Closure type could be one that takes in some <code>Int</code> and returns some <code>String</code>.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> closure: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>

closure = { times <span class="hljs-keyword">in</span>
    <span class="hljs-type">String</span>(repeating: <span class="hljs-string">"üß±"</span>, <span class="hljs-built_in">count</span>: times)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(times: Int)</span></span> -&gt; <span class="hljs-type">String</span> {
    <span class="hljs-type">String</span>(repeating: <span class="hljs-string">"üß±"</span>, <span class="hljs-built_in">count</span>: times)
}

<span class="hljs-built_in">print</span>(closure(<span class="hljs-number">3</span>)) <span class="hljs-comment">// üß±üß±üß±</span>
<span class="hljs-built_in">print</span>(function(times: <span class="hljs-number">3</span>)) <span class="hljs-comment">// üß±üß±üß±</span>
</code></pre><p>Notice that the function has the same Closure type except that it has a named parameter <code>(times: Int) -&gt; String</code>. To show this we can have another function that has a parameter of <code>(Int) -&gt; String</code>.</p><pre id=pre-swift data-language="swift" "><code><span class="hljs-keyword">let</span> closure: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>

closure = { times <span class="hljs-keyword">in</span>
    <span class="hljs-type">String</span>(repeating: <span class="hljs-string">"üß±"</span>, <span class="hljs-built_in">count</span>: times)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(times: Int)</span></span> -&gt; <span class="hljs-type">String</span> {
    <span class="hljs-type">String</span>(repeating: <span class="hljs-string">"üß±"</span>, <span class="hljs-built_in">count</span>: times)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">task</span><span class="hljs-params">(closure: <span class="hljs-params">(Int)</span></span></span> -&gt; <span class="hljs-type">String</span>) {
    <span class="hljs-built_in">print</span>(closure(<span class="hljs-number">5</span>))
}

task(closure: closure) <span class="hljs-comment">// üß±üß±üß±üß±üß±</span>
task(closure: function) <span class="hljs-comment">// üß±üß±üß±üß±üß±</span>
</code></pre>]]></content:encoded></item></channel></rss>